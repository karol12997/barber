// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { hydrate } from './hydrate.js';
import { commitMainThreadPatchUpdate } from './lifecycle/patch/updateMainThread.js';
// class ListUpdateInfoDiffing implements ListUpdateInfo {
//   private oldChildNodes: SnapshotInstance[];
//   constructor(private list: SnapshotInstance) {
//     this.oldChildNodes = list.childNodes;
//   }
//   flush(): void {
//     Object.defineProperty(SnapshotInstance.prototype, "key", {
//       get: function () {
//         return this.values[0]["item-key"];
//       },
//     });
//   }
//   onInsertBefore(newNode: SnapshotInstance, existingNode?: SnapshotInstance | undefined): void {}
//   onRemoveChild(child: SnapshotInstance): void {}
//   onSetAttribute(child: SnapshotInstance, attr: any): void {
//     throw new Error("Method not implemented.");
//   }
// }
export class ListUpdateInfoRecording {
    list;
    constructor(list) {
        this.list = list;
        this.oldChildNodes = list.childNodes;
        // this.oldChildNodesSet = new Set(this.oldChildNodes);
    }
    // private __commitAndReset() {
    //   (this.__pendingAttributes ??= []).push(this.__toAttribute());
    //   this.oldChildNodes = this.list.childNodes;
    //   this.oldChildNodesSet = new Set(this.oldChildNodes);
    //   this.removeChild1.clear();
    //   this.removeChild2.clear();
    //   this.insertBefore.clear();
    //   this.appendChild.length = 0;
    //   this.platformInfoUpdate.clear();
    // }
    flush() {
        const elementIndex = this.list.__snapshot_def.slot[0][1];
        const listElement = this.list.__elements[elementIndex];
        // this.__pendingAttributes?.forEach(pendingAttribute => {
        //   __SetAttribute(listElement, "update-list-info", pendingAttribute);
        //   __FlushElementTree(listElement);
        // });
        __SetAttribute(listElement, 'update-list-info', this.__toAttribute());
        __UpdateListCallbacks(listElement, componentAtIndexFactory(this.list.childNodes), enqueueComponentFactory());
    }
    oldChildNodes;
    // private oldChildNodesSet: Set<SnapshotInstance>;
    removeChild = new Set();
    insertBefore = new Map(); // insert V before K
    appendChild = [];
    platformInfoUpdate = new Map();
    onInsertBefore(newNode, existingNode) {
        // @ts-ignore
        if (newNode.__parent) {
            // if (!this.oldChildNodesSet.has(newNode)) {
            //   this.__commitAndReset();
            // }
            this.removeChild.add(newNode);
        }
        if (existingNode) {
            // if (!this.oldChildNodesSet.has(existingNode)) {
            //   this.__commitAndReset();
            // }
            const newChildren = this.insertBefore.get(existingNode) ?? [];
            newChildren.push(newNode);
            this.insertBefore.set(existingNode, newChildren);
        }
        else {
            this.appendChild.push(newNode);
        }
    }
    onRemoveChild(child) {
        // if (!this.oldChildNodesSet.has(child)) {
        //   this.__commitAndReset();
        // }
        this.removeChild.add(child);
    }
    onSetAttribute(child, attr, _oldAttr) {
        this.platformInfoUpdate.set(child, attr);
    }
    __toAttribute() {
        const { removeChild, insertBefore, appendChild, platformInfoUpdate } = this;
        const removals = [];
        const insertions = [];
        const updates = [];
        let j = 0;
        for (let i = 0; i < this.oldChildNodes.length; i++, j++) {
            const child = this.oldChildNodes[i];
            if (platformInfoUpdate.has(child)) {
                updates.push({
                    ...platformInfoUpdate.get(child),
                    from: +j,
                    to: +j,
                    // no flush
                    flush: false,
                    type: child.type,
                });
            }
            if (insertBefore.has(child)) {
                const children = insertBefore.get(child);
                children.forEach(c => {
                    insertions.push({
                        position: j,
                        type: c.type,
                        ...c.__listItemPlatformInfo,
                    });
                    j++;
                });
            }
            if (removeChild.has(child)) {
                removals.push(i);
                removeChild.delete(child);
                j--;
            }
        }
        for (let i = 0; i < appendChild.length; i++) {
            const child = appendChild[i];
            insertions.push({
                position: j + i,
                type: child.type,
                ...child.__listItemPlatformInfo,
            });
        }
        insertions.sort((a, b) => a.position - b.position);
        removals.sort((a, b) => a - b);
        if (SystemInfo.lynxSdkVersion === '2.14'
            || SystemInfo.lynxSdkVersion === '2.15'
            || SystemInfo.lynxSdkVersion === '2.16'
            || SystemInfo.lynxSdkVersion === '2.17'
            || SystemInfo.lynxSdkVersion === '2.18') {
            const elementIndex = this.list.__snapshot_def.slot[0][1];
            const listElement = this.list.__elements[elementIndex];
            // `__GetAttributeByName` is avaiable since Lynx 2.14
            if (__GetAttributeByName(listElement, 'custom-list-name') === 'list-container') {
                // `updateAction` must be full (not incremental) when Lynx version <= 2.18 and
                // when `custom-list-name` is `list-container` (avaiable when Lynx version >= 2.14) is true,
                updates.length = 0;
                this.list.childNodes.forEach((child, index) => {
                    updates.push({
                        ...child.__listItemPlatformInfo,
                        from: index,
                        to: index,
                        // no flush
                        flush: false,
                        type: child.type,
                    });
                });
            }
        }
        return {
            insertAction: insertions,
            removeAction: removals,
            updateAction: updates,
        };
    }
    toJSON() {
        // if (this.__pendingAttributes) {
        //   return [...this.__pendingAttributes, this.__toAttribute()];
        // } else {
        //   return [this.__toAttribute()];
        // }
        return [this.__toAttribute()];
    }
}
export const __pendingListUpdates = {
    values: {},
    clear() {
        this.values = {};
    },
    flush() {
        Object.values(this.values).forEach(update => {
            update.flush();
        });
        this.clear();
    },
};
export const gSignMap = {};
export const gRecycleMap = {};
export function clearListGlobal() {
    for (const key in gSignMap) {
        delete gSignMap[key];
    }
    for (const key in gRecycleMap) {
        delete gRecycleMap[key];
    }
}
export function componentAtIndexFactory(ctx) {
    const componentAtIndex = (list, listID, cellIndex, operationID, enableReuseNotification) => {
        const signMap = gSignMap[listID];
        const recycleMap = gRecycleMap[listID];
        if (!signMap || !recycleMap) {
            throw new Error('componentAtIndex called on removed list');
        }
        const childCtx = ctx[cellIndex];
        if (!childCtx) {
            throw new Error('childCtx not found');
        }
        const platformInfo = childCtx.__listItemPlatformInfo || {};
        const uniqID = childCtx.type + (platformInfo['reuse-identifier'] ?? '');
        const recycleSignMap = recycleMap.get(uniqID);
        if (childCtx.__elements) {
            /**
             * If this situation is encountered, there might be two cases:
             * 1. Reusing with itself
             *    In this case, enqueueComponent will be triggered first, followed by componentAtIndex.
             * 2. Moving
             *    In this case, the trigger order is uncertain; componentAtIndex might be triggered first, or enqueueComponent might be triggered first.
             *
             * When enqueueComponent is triggered first, there must be an item in the reuse pool with the same sign as here, which can be returned directly.
             * When componentAtIndex is triggered first, a clone needs to be made first, then follow the logic for adding or reusing. The cloned item will enter the reuse pool in the subsequent enqueueComponent.
             */
            const root = childCtx.__elements[0];
            const sign = __GetElementUniqueID(root);
            if (recycleSignMap?.has(sign)) {
                signMap.set(sign, childCtx);
                recycleSignMap.delete(sign);
                __FlushElementTree(root, { triggerLayout: true, operationID, elementID: sign, listID });
                return sign;
            }
            else {
                const newCtx = childCtx.takeElements();
                signMap.set(sign, newCtx);
            }
        }
        if (recycleSignMap && recycleSignMap.size > 0) {
            const [first] = recycleSignMap;
            const [sign, oldCtx] = first;
            recycleSignMap.delete(sign);
            hydrate(oldCtx, childCtx);
            oldCtx.unRenderElements();
            const root = childCtx.__element_root;
            if (enableReuseNotification) {
                __FlushElementTree(root, {
                    triggerLayout: true,
                    operationID,
                    elementID: sign,
                    listID,
                    listReuseNotification: {
                        listElement: list,
                        itemKey: platformInfo['item-key'],
                    },
                });
            }
            else {
                __FlushElementTree(root, {
                    triggerLayout: true,
                    operationID,
                    elementID: sign,
                    listID,
                });
            }
            signMap.set(sign, childCtx);
            commitMainThreadPatchUpdate(undefined);
            return sign;
        }
        childCtx.ensureElements();
        const root = childCtx.__element_root;
        __AppendElement(list, root);
        const sign = __GetElementUniqueID(root);
        __FlushElementTree(root, {
            triggerLayout: true,
            operationID,
            elementID: sign,
            listID,
        });
        signMap.set(sign, childCtx);
        commitMainThreadPatchUpdate(undefined);
        return sign;
    };
    return componentAtIndex;
}
export function enqueueComponentFactory() {
    const enqueueComponent = (_, listID, sign) => {
        const signMap = gSignMap[listID];
        const recycleMap = gRecycleMap[listID];
        if (!signMap || !recycleMap) {
            throw new Error('enqueueComponent called on removed list');
        }
        const childCtx = signMap.get(sign);
        if (!childCtx) {
            return;
        }
        const platformInfo = childCtx.__listItemPlatformInfo || {};
        const uniqID = childCtx.type + (platformInfo['reuse-identifier'] ?? '');
        if (!recycleMap.has(uniqID)) {
            recycleMap.set(uniqID, new Map());
        }
        recycleMap.get(uniqID).set(sign, childCtx);
    };
    return enqueueComponent;
}
export function snapshotCreateList(pageId, _ctx, _expIndex) {
    const signMap = new Map();
    const recycleMap = new Map();
    const list = __CreateList(pageId, componentAtIndexFactory([]), enqueueComponentFactory(), {});
    const listID = __GetElementUniqueID(list);
    gSignMap[listID] = signMap;
    gRecycleMap[listID] = recycleMap;
    return list;
}
export function snapshotDestroyList(si) {
    const [, elementIndex] = si.__snapshot_def.slot[0];
    const list = si.__elements[elementIndex];
    const listID = __GetElementUniqueID(list);
    delete gSignMap[listID];
    delete gRecycleMap[listID];
}
//# sourceMappingURL=list.js.map
import { GestureTypeInner, } from './types.js';
import { onWorkletCtxUpdate } from '@lynx-js/react/worklet-runtime/bindings';
function isSerializedGesture(gesture) {
    return gesture.__isSerialized ?? false;
}
function getGestureInfo(gesture, dom) {
    const config = {
        callbacks: [],
    };
    const baseGesture = gesture;
    if (baseGesture.config) {
        config.config = baseGesture.config;
    }
    for (const key of Object.keys(baseGesture.callbacks)) {
        const callback = baseGesture.callbacks[key];
        onWorkletCtxUpdate(callback, dom);
        config.callbacks.push({
            name: key,
            callback: callback,
        });
    }
    const relationMap = {
        waitFor: baseGesture?.waitFor?.map(subGesture => subGesture.id) ?? [],
        simultaneous: baseGesture?.simultaneousWith?.map(subGesture => subGesture.id) ?? [],
        continueWith: baseGesture?.continueWith?.map(subGesture => subGesture.id) ?? [],
    };
    return {
        config,
        relationMap,
    };
}
export function processGesture(dom, gesture, gestureOptions) {
    if (!gesture || !isSerializedGesture(gesture)) {
        return;
    }
    if (!(gestureOptions && gestureOptions.domSet)) {
        __SetAttribute(dom, 'has-react-gesture', true);
        __SetAttribute(dom, 'flatten', false);
    }
    if (gesture.type === GestureTypeInner.COMPOSED) {
        for (const subGesture of gesture.gestures) {
            processGesture(dom, subGesture, { domSet: true });
        }
    }
    else {
        const baseGesture = gesture;
        const { config, relationMap } = getGestureInfo(baseGesture, dom);
        __SetGestureDetector(dom, baseGesture.id, baseGesture.type, config, relationMap);
    }
}
//# sourceMappingURL=processGesture.js.map
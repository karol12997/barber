import { options } from 'preact';
import { takeGlobalSnapshotPatch } from './snapshotPatch.js';
import { LifecycleConstant } from '../../lifecycleConstant.js';
import { PerformanceTimingKeys, globalPipelineOptions, markTiming, markTimingLegacy, setPipeline, } from '../../lynx/performance.js';
import { CATCH_ERROR, COMMIT, RENDER_CALLBACKS, VNODE } from '../../renderToOpcodes/constants.js';
import { updateBackgroundRefs } from '../../snapshot/ref.js';
import { backgroundSnapshotInstanceManager } from '../../snapshot.js';
import { isEmptyObject } from '../../utils.js';
import { takeWorkletRefInitValuePatch } from '../../worklet/workletRefPool.js';
import { runDelayedUnmounts, takeDelayedUnmounts } from '../delayUnmount.js';
import { getReloadVersion } from '../pass.js';
let globalFlushOptions = {};
const globalCommitTaskMap = /*@__PURE__*/ new Map();
let nextCommitTaskId = 1;
let globalBackgroundSnapshotInstancesToRemove = [];
let patchesToCommit = [];
function clearPatchesToCommit() {
    patchesToCommit = [];
}
function replaceCommitHook() {
    const injectDebounceRendering = (debounceRendering) => {
        return (f) => {
            debounceRendering(() => {
                f();
                void commitToMainThread();
            });
        };
    };
    const defaultDebounceRendering = options.debounceRendering?.bind(options)
        ?? Promise.prototype.then.bind(Promise.resolve());
    let _debounceRendering = injectDebounceRendering(defaultDebounceRendering);
    Object.defineProperty(options, 'debounceRendering', {
        get() {
            return _debounceRendering;
        },
        set(debounceRendering) {
            _debounceRendering = injectDebounceRendering(debounceRendering);
        },
    });
    const oldCommit = options[COMMIT];
    const commit = async (vnode, commitQueue) => {
        if (__LEPUS__) {
            // for testing only
            commitQueue.length = 0;
            return;
        }
        const renderCallbacks = commitQueue.map((component) => {
            const ret = {
                component,
                [RENDER_CALLBACKS]: component[RENDER_CALLBACKS],
                [VNODE]: component[VNODE],
            };
            component[RENDER_CALLBACKS] = [];
            return ret;
        });
        commitQueue.length = 0;
        const delayedUnmounts = takeDelayedUnmounts();
        const backgroundSnapshotInstancesToRemove = globalBackgroundSnapshotInstancesToRemove;
        globalBackgroundSnapshotInstancesToRemove = [];
        const commitTaskId = genCommitTaskId();
        globalCommitTaskMap.set(commitTaskId, () => {
            updateBackgroundRefs(commitTaskId);
            runDelayedUnmounts(delayedUnmounts);
            oldCommit?.(vnode, renderCallbacks);
            renderCallbacks.some(wrapper => {
                try {
                    wrapper[RENDER_CALLBACKS].some((cb) => {
                        cb.call(wrapper.component);
                    });
                }
                catch (e) {
                    options[CATCH_ERROR](e, wrapper[VNODE]);
                }
            });
            if (backgroundSnapshotInstancesToRemove.length) {
                setTimeout(() => {
                    backgroundSnapshotInstancesToRemove.forEach(id => {
                        backgroundSnapshotInstanceManager.values.delete(id);
                    });
                }, 10000);
            }
        });
        const snapshotPatch = takeGlobalSnapshotPatch();
        const workletRefInitValuePatch = takeWorkletRefInitValuePatch();
        if (!snapshotPatch && workletRefInitValuePatch.length === 0) {
            // before hydration, skip patch
            return;
        }
        const patch = {
            id: commitTaskId,
        };
        // TODO: check all fields in `flushOptions` from runtime3
        if (snapshotPatch?.length) {
            patch.snapshotPatch = snapshotPatch;
        }
        if (workletRefInitValuePatch.length) {
            patch.workletRefInitValuePatch = workletRefInitValuePatch;
        }
        patchesToCommit.push(patch);
    };
    options[COMMIT] = commit;
}
async function commitToMainThread() {
    if (patchesToCommit.length === 0) {
        return;
    }
    markTimingLegacy(PerformanceTimingKeys.updateDiffVdomEnd);
    markTiming(PerformanceTimingKeys.diffVdomEnd);
    const flushOptions = globalFlushOptions;
    globalFlushOptions = {};
    const patchList = {
        patchList: patchesToCommit,
    };
    patchesToCommit = [];
    if (!isEmptyObject(flushOptions)) {
        patchList.flushOptions = flushOptions;
    }
    const obj = commitPatchUpdate(patchList, {});
    lynx.getNativeApp().callLepusMethod(LifecycleConstant.patchUpdate, obj, () => {
        for (let i = 0; i < patchList.patchList.length; i++) {
            const patch = patchList.patchList[i];
            const commitTask = globalCommitTaskMap.get(patch.id);
            if (commitTask) {
                commitTask();
                globalCommitTaskMap.delete(patch.id);
            }
        }
    });
}
function commitPatchUpdate(patchList, patchOptions) {
    // console.debug('********** JS update:');
    // printSnapshotInstance(
    //   (backgroundSnapshotInstanceManager.values.get(1) || backgroundSnapshotInstanceManager.values.get(-1))!,
    // );
    // console.debug('commitPatchUpdate: ', JSON.stringify(patchList));
    if (__PROFILE__) {
        console.profile('commitChanges');
    }
    markTiming(PerformanceTimingKeys.packChangesStart);
    const obj = {
        data: JSON.stringify(patchList),
        patchOptions: {
            ...patchOptions,
            reloadVersion: getReloadVersion(),
        },
    };
    markTiming(PerformanceTimingKeys.packChangesEnd);
    if (globalPipelineOptions) {
        obj.patchOptions.pipelineOptions = globalPipelineOptions;
        setPipeline(undefined);
    }
    if (__PROFILE__) {
        console.profileEnd();
    }
    return obj;
}
function genCommitTaskId() {
    return nextCommitTaskId++;
}
function clearCommitTaskId() {
    nextCommitTaskId = 1;
}
function replaceRequestAnimationFrame() {
    // to make afterPaintEffects run faster
    const resolvedPromise = Promise.resolve();
    options.requestAnimationFrame = (cb) => {
        void resolvedPromise.then(cb);
    };
}
/**
 * @internal
 */
export { commitPatchUpdate, commitToMainThread, genCommitTaskId, clearCommitTaskId, globalBackgroundSnapshotInstancesToRemove, globalCommitTaskMap, globalFlushOptions, nextCommitTaskId, patchesToCommit, clearPatchesToCommit, replaceCommitHook, replaceRequestAnimationFrame, };
//# sourceMappingURL=commit.js.map